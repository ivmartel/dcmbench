{"version":3,"sources":["webpack://dicom-character-set/webpack/universalModuleDefinition","webpack://dicom-character-set/webpack/bootstrap","webpack://dicom-character-set/webpack/runtime/define property getters","webpack://dicom-character-set/webpack/runtime/hasOwnProperty shorthand","webpack://dicom-character-set/webpack/runtime/make namespace object","webpack://dicom-character-set/./convert-bytes.js","webpack://dicom-character-set/./character-sets.js"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","specificCharacterSet","bytes","options","convertBytesCore","convertWithoutExtensions","appendRunWithoutPromise","convertWithoutExtensionsPromise","appendRunWithPromise","asciiElement","codeElement","escapeSequence","encoding","isASCII","bytesPerCodePoint","characterSets","extension","elements","multiByte","setHighBit","isJISX0212","GB18030","GBK","ESCAPE_BYTE","CARRIAGE_RETURN","LINE_FEED","FORM_FEED","TAB","BACKSLASH","EQUAL_SIGN","CARET","adjustShiftJISResult","str","replace","output","byteRunCharacterSet","byteRunStart","byteRunEnd","oneRunBytes","preprocessBytes","Promise","resolve","then","lhs","rhs","withoutExtensionsFunc","appendFunc","Uint8Array","Error","checkParameters","characterSetStrings","split","map","characterSet","trim","toUpperCase","length","some","undefined","forceExtensions","returnValue","i","characterSetString","includes","push","forceExtensionsIfApplicable","initialCharacterSet","filter","filterMultiByteCharacterSetStrings","getCharacterSetStrings","startsWith","checkedOptions","allowedCharacterSets","delimiters","appendRun","initialCharacterSets","G0","find","element","G1","activeCharacterSets","assign","nextSetIndex","getCharacterSet","next","start","currentCodeElement","activeCodeElements","index","nextCodeElement","findNextCharacterSet","nextCharacterSet","extensionSets","setIndex","extensionSet","elementIndex","startIndex","escapeByteIndex","escapeSequenceMatches","readEscapeSequence","convertWithExtensions","incomingVR","vr","getDelimitersForVR","decoders","decoder","TextDecoder","textDecoder","decode","b","fileReader","FileReader","onload","result","blob","Blob","readAsText","byte","byteStart","byteEnd","oneEncodingBytes","bytesStart","bytesEnd","processedBytes","outIndex","processJISX0212","set","buffer","byteOffset"],"mappings":"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","file":"dicom-character-set.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"dicom-character-set\"] = factory();\n\telse\n\t\troot[\"dicom-character-set\"] = factory();\n})(this, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { characterSets } from './character-sets.js';\n\nconst ESCAPE_BYTE = 0x1B;\n\nconst CARRIAGE_RETURN = 0xA;\nconst LINE_FEED = 0xC;\nconst FORM_FEED = 0xD;\nconst TAB = 0x9;\n// Aka yen symbol in Romaji\nconst BACKSLASH = 0x5C;\nconst EQUAL_SIGN = 0x3D;\nconst CARET = 0x5E;\n\nfunction adjustShiftJISResult (str) {\n  // browsers do strict ASCII for these characters, so to be compliant with Shift JIS we replace them\n  return str.replace(/~/g, '‾').replace(/\\\\/g, '¥');\n}\n\nfunction appendRunWithoutPromise (output, byteRunCharacterSet, bytes, byteRunStart, byteRunEnd) {\n  const oneRunBytes = preprocessBytes(byteRunCharacterSet, bytes, byteRunStart, byteRunEnd);\n\n  return output + convertWithoutExtensions(byteRunCharacterSet.encoding, oneRunBytes);\n}\n\nfunction appendRunWithPromise (output, byteRunCharacterSet, bytes, byteRunStart, byteRunEnd) {\n  const oneRunBytes = preprocessBytes(byteRunCharacterSet, bytes, byteRunStart, byteRunEnd);\n\n  return (output === '' ? Promise.resolve('') : output).then((lhs) => convertWithoutExtensionsPromise(byteRunCharacterSet.encoding, oneRunBytes).then((rhs) => lhs + rhs));\n}\n\nfunction checkParameters (specificCharacterSet, bytes) {\n  if (bytes && !(bytes instanceof Uint8Array)) {\n    throw new Error('bytes must be a Uint8Array');\n  }\n  if (specificCharacterSet && (typeof specificCharacterSet !== 'string')) {\n    throw new Error('specificCharacterSet must be a string');\n  }\n}\n\nfunction convertBytesCore (withoutExtensionsFunc, appendFunc, specificCharacterSet, bytes, options) {\n  checkParameters(specificCharacterSet, bytes);\n\n  const characterSetStrings = getCharacterSetStrings(specificCharacterSet);\n\n  if (characterSetStrings.length === 1 && !characterSetStrings[0].startsWith('ISO 2022')) {\n    return withoutExtensionsFunc(characterSets[characterSetStrings[0]].encoding, bytes);\n  }\n\n  const checkedOptions = options || {};\n\n  return convertWithExtensions(characterSetStrings.map((characterSet) => characterSets[characterSet]),\n    bytes, getDelimitersForVR(checkedOptions.vr), appendFunc);\n}\n\nfunction convertWithExtensions (allowedCharacterSets, bytes, delimiters, appendRun) {\n  let output = '';\n\n  if (!bytes || bytes.length === 0) {\n    return output;\n  }\n\n  const initialCharacterSets = {\n    G0: allowedCharacterSets[0].elements.find((element) => element.codeElement === 'G0'),\n    G1: allowedCharacterSets[0].elements.find((element) => element.codeElement === 'G1')\n  };\n\n  const activeCharacterSets = Object.assign({}, initialCharacterSets);\n  let byteRunStart = 0;\n  let byteRunCharacterSet;\n  let nextSetIndex = 0;\n\n  // Group bytes into runs based on their encoding so we don't have to use a different\n  // decoder for each character. Note that G0 and G1 planes can be different encodings,\n  // so we can't just group by character set.\n\n  while (nextSetIndex < bytes.length) {\n    if (!byteRunCharacterSet) {\n      byteRunCharacterSet = getCharacterSet(bytes[byteRunStart], activeCharacterSets);\n    }\n\n    const next = findNextCharacterSet(bytes, byteRunStart, byteRunCharacterSet,\n      activeCharacterSets, initialCharacterSets, delimiters);\n\n    nextSetIndex = next.index;\n\n    if (nextSetIndex > byteRunStart) {\n      output = appendRun(output, byteRunCharacterSet, bytes, byteRunStart, nextSetIndex);\n    }\n\n    byteRunStart = nextSetIndex;\n    byteRunCharacterSet = next.characterSet;\n\n    if (next.escapeSequence) {\n      const nextCharacterSet = readEscapeSequence(bytes, nextSetIndex, allowedCharacterSets);\n\n      activeCharacterSets[nextCharacterSet.codeElement] = nextCharacterSet;\n      byteRunStart += nextCharacterSet.escapeSequence.length;\n    }\n  }\n\n  return output;\n}\n\nconst decoders = {};\n\nfunction convertWithoutExtensions (encoding, bytes) {\n  let decoder = decoders[encoding];\n\n  if (!decoder) {\n    decoder = new TextDecoder(encoding);\n    if (encoding === 'shift-jis') {\n      decoder = {\n        textDecoder: decoder,\n        decode: (b) => adjustShiftJISResult(decoder.decode(b))\n      };\n    }\n    decoders[encoding] = decoder;\n  }\n\n  return decoder.decode(bytes);\n}\n\nfunction convertWithoutExtensionsPromise (encoding, bytes) {\n  return new Promise((resolve) => {\n    const fileReader = new FileReader();\n\n    if (encoding === 'shift-jis') {\n      fileReader.onload = () => resolve(adjustShiftJISResult(fileReader.result));\n    } else {\n      fileReader.onload = () => resolve(fileReader.result);\n    }\n\n    const blob = new Blob([bytes]);\n\n    fileReader.readAsText(blob, encoding);\n  });\n}\n\n// Multibyte non-extension character sets must stand on their own or else be ignored. This method enforces that.\nfunction filterMultiByteCharacterSetStrings (characterSetStrings) {\n  const initialCharacterSet = characterSets[characterSetStrings[0]];\n\n  if (initialCharacterSet.multiByte && !initialCharacterSet.extension) {\n    return [characterSetStrings[0]];\n  }\n\n  return characterSetStrings.filter((str) => !characterSets[str].multiByte || characterSets[str].extension);\n}\n\nfunction findNextCharacterSet (bytes, start, currentCodeElement, activeCodeElements, initialCharacterSets, delimiters) {\n  for (let i = start; i < bytes.length; i += currentCodeElement.bytesPerCodePoint) {\n    if (bytes[i] === ESCAPE_BYTE) {\n      return { escapeSequence: true,\n        index: i };\n    }\n    if (currentCodeElement.bytesPerCodePoint === 1 && delimiters.includes(bytes[i])) {\n      Object.assign(activeCodeElements, initialCharacterSets);\n    }\n    const nextCodeElement = getCharacterSet(bytes[i], activeCodeElements);\n\n    if (currentCodeElement && nextCodeElement !== currentCodeElement) {\n      return { characterSet: nextCodeElement,\n        index: i };\n    }\n  }\n\n  return { index: bytes.length };\n}\n\nfunction forceExtensionsIfApplicable (characterSetStrings) {\n  const forceExtensions = (characterSetStrings.length > 1);\n\n  const returnValue = [];\n\n  for (let i = 0; i < characterSetStrings.length; i++) {\n    const characterSetString = characterSetStrings[i];\n\n    if (!returnValue.includes(characterSetString)) {\n      returnValue.push(forceExtensions ? characterSetString.replace('ISO_IR', 'ISO 2022 IR') : characterSetString);\n    }\n  }\n\n  return returnValue;\n}\n\nfunction getCharacterSet (byte, activeCharacterSets) {\n  if (byte > 0x7F && activeCharacterSets.G1) {\n    return activeCharacterSets.G1;\n  }\n  if (activeCharacterSets.G0) {\n    return activeCharacterSets.G0;\n  }\n  // for robustness if byte <= 0x7F, try to output using G1 if no G0 is selected\n  if (activeCharacterSets.G1 && activeCharacterSets.G1.bytesPerCodePoint === 1) {\n    return activeCharacterSets.G1;\n  }\n  // If G1 is multibyte, default to ASCII\n\n  return characterSets['ISO 2022 IR 6'].elements[0];\n}\n\nfunction getCharacterSetStrings (specificCharacterSet) {\n  let characterSetStrings = specificCharacterSet ? specificCharacterSet.split('\\\\').map((characterSet) => characterSet.trim().toUpperCase()) : [''];\n\n  if (characterSetStrings[0] === '') {\n    characterSetStrings[0] = (characterSetStrings.length > 1) ? 'ISO 2022 IR 6' : 'ISO_IR 6';\n  }\n\n  if (characterSetStrings.some((characterSet) => characterSets[characterSet] === undefined)) {\n    throw new Error('Invalid specific character set specified.');\n  }\n\n  characterSetStrings = filterMultiByteCharacterSetStrings(characterSetStrings);\n\n  return forceExtensionsIfApplicable(characterSetStrings);\n}\n\nfunction getDelimitersForVR (incomingVR) {\n  const vr = (incomingVR || '').trim().toUpperCase();\n\n  const delimiters = [CARRIAGE_RETURN, LINE_FEED, FORM_FEED, TAB];\n\n  if (!['UT', 'ST', 'LT'].includes(vr)) {\n    // for delimiting multi-valued items\n    delimiters.push(BACKSLASH);\n  }\n  if (vr === 'PN') {\n    delimiters.push(EQUAL_SIGN);\n    delimiters.push(CARET);\n  }\n\n  return delimiters;\n}\n\nfunction preprocessBytes (characterSet, bytes, byteStart, byteEnd) {\n  let oneEncodingBytes;\n\n  if (characterSet.isJISX0212) {\n    oneEncodingBytes = processJISX0212(bytes, byteStart, byteEnd);\n  } else {\n    oneEncodingBytes = new Uint8Array(byteEnd - byteStart);\n    oneEncodingBytes.set(new Uint8Array(bytes.buffer, bytes.byteOffset + byteStart, byteEnd - byteStart));\n    if (characterSet.setHighBit) {\n      setHighBit(oneEncodingBytes);\n    }\n  }\n\n  return oneEncodingBytes;\n}\n\nfunction processJISX0212 (bytes, bytesStart, bytesEnd) {\n  const length = bytesEnd - bytesStart;\n\n  if (length % 2 !== 0) {\n    throw new Error('JIS X string with a character not having exactly two bytes!');\n  }\n\n  const processedBytes = new Uint8Array(length + (length / 2));\n  let outIndex = 0;\n\n  for (let i = bytesStart; i < bytesEnd; i += 2) {\n    processedBytes[outIndex++] = 0x8F;\n    processedBytes[outIndex++] = bytes[i] | 0x80;\n    processedBytes[outIndex++] = bytes[i + 1] | 0x80;\n  }\n\n  return processedBytes;\n}\n\nfunction escapeSequenceMatches (escapeSequence, bytes, startIndex) {\n  for (let escapeByteIndex = 0; escapeByteIndex < escapeSequence.length; escapeByteIndex++) {\n    if (startIndex + escapeByteIndex >= bytes.length) {\n      return false;\n    } else if (bytes[startIndex + escapeByteIndex] !== escapeSequence[escapeByteIndex]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction readEscapeSequence (bytes, start, extensionSets) {\n  for (let setIndex = 0; setIndex < extensionSets.length; setIndex++) {\n    const extensionSet = extensionSets[setIndex];\n\n    for (let elementIndex = 0; elementIndex < extensionSet.elements.length; elementIndex++) {\n      const element = extensionSet.elements[elementIndex];\n\n      if (escapeSequenceMatches(element.escapeSequence, bytes, start)) {\n        return element;\n      }\n    }\n  }\n\n  throw new Error(`Unknown escape sequence encountered at byte ${start}`);\n}\n\nfunction setHighBit (bytes) {\n  for (let i = 0; i < bytes.length; i++) {\n    bytes[i] |= 0x80;\n  }\n}\n\nexport function convertBytes (specificCharacterSet, bytes, options) {\n  return convertBytesCore(convertWithoutExtensions, appendRunWithoutPromise, specificCharacterSet, bytes, options);\n}\n\nexport function convertBytesPromise (specificCharacterSet, bytes, options) {\n  return convertBytesCore(convertWithoutExtensionsPromise, appendRunWithPromise, specificCharacterSet, bytes, options);\n}\n","const asciiElement = { codeElement: 'G0',\n  escapeSequence: [0x1B, 0x28, 0x42],\n  encoding: 'windows-1252',\n  isASCII: true,\n  bytesPerCodePoint: 1 };\n\nexport const characterSets = {\n\n  /** ********************************\n   * Single-byte without extensions *\n   **********************************/\n\n  // Default\n  'ISO_IR 6': { encoding: 'utf-8' },\n\n  // Latin alphabet No. 1\n  'ISO_IR 100': { encoding: 'windows-1252' },\n\n  // Latin alphabet No. 2\n  'ISO_IR 101': { encoding: 'iso-8859-2' },\n\n  // Latin alphabet No. 3\n  'ISO_IR 109': { encoding: 'iso-8859-3' },\n\n  // Latin alphabet No. 4\n  'ISO_IR 110': { encoding: 'iso-8859-4' },\n\n  // Cyrillic\n  'ISO_IR 144': { encoding: 'iso-8859-5' },\n\n  // Arabic\n  'ISO_IR 127': { encoding: 'iso-8859-6' },\n\n  // Greek\n  'ISO_IR 126': { encoding: 'iso-8859-7' },\n\n  // Hebrew\n  'ISO_IR 138': { encoding: 'iso-8859-8' },\n\n  // Latin alphabet No. 5\n  'ISO_IR 148': { encoding: 'windows-1254' },\n\n  // Japanese\n  'ISO_IR 13': { encoding: 'shift-jis' },\n\n  // Thai\n  'ISO_IR 166': { encoding: 'tis-620' },\n\n  /** *****************************\n   * Single-byte with extensions *\n   *******************************/\n\n  // Default\n  'ISO 2022 IR 6': {\n    extension: true,\n    elements: [asciiElement]\n  },\n\n  // Latin alphabet No. 1\n  'ISO 2022 IR 100': {\n    extension: true,\n    elements: [asciiElement, { codeElement: 'G1',\n      escapeSequence: [0x1B, 0x2D, 0x41],\n      encoding: 'windows-1252',\n      bytesPerCodePoint: 1 }]\n  },\n\n  // Latin alphabet No. 2\n  'ISO 2022 IR 101': {\n    extension: true,\n    elements: [asciiElement, { codeElement: 'G1',\n      escapeSequence: [0x1B, 0x2D, 0x42],\n      encoding: 'iso-8859-2',\n      bytesPerCodePoint: 1 }]\n  },\n\n  // Latin alphabet No. 3\n  'ISO 2022 IR 109': {\n    extension: true,\n    elements: [asciiElement, { codeElement: 'G1',\n      escapeSequence: [0x1B, 0x2D, 0x43],\n      encoding: 'iso-8859-3',\n      bytesPerCodePoint: 1 }]\n  },\n\n  // Latin alphabet No. 4\n  'ISO 2022 IR 110': {\n    extension: true,\n    elements: [asciiElement, { codeElement: 'G1',\n      escapeSequence: [0x1B, 0x2D, 0x44],\n      encoding: 'iso-8859-4',\n      bytesPerCodePoint: 1 }]\n  },\n\n  // Cyrillic\n  'ISO 2022 IR 144': {\n    extension: true,\n    elements: [asciiElement, { codeElement: 'G1',\n      escapeSequence: [0x1B, 0x2D, 0x4C],\n      encoding: 'iso-8859-5',\n      bytesPerCodePoint: 1 }]\n  },\n\n  // Arabic\n  'ISO 2022 IR 127': {\n    extension: true,\n    elements: [asciiElement, { codeElement: 'G1',\n      escapeSequence: [0x1B, 0x2D, 0x47],\n      encoding: 'iso-8859-6',\n      bytesPerCodePoint: 1 }]\n  },\n\n  // Greek\n  'ISO 2022 IR 126': {\n    extension: true,\n    elements: [asciiElement, { codeElement: 'G1',\n      escapeSequence: [0x1B, 0x2D, 0x46],\n      encoding: 'iso-8859-7',\n      bytesPerCodePoint: 1 }]\n  },\n\n  // Hebrew\n  'ISO 2022 IR 138': {\n    extension: true,\n    elements: [asciiElement, { codeElement: 'G1',\n      escapeSequence: [0x1B, 0x2D, 0x48],\n      encoding: 'iso-8859-8',\n      bytesPerCodePoint: 1 }]\n  },\n\n  // Latin alphabet No. 5\n  'ISO 2022 IR 148': {\n    extension: true,\n    elements: [asciiElement, { codeElement: 'G1',\n      escapeSequence: [0x1B, 0x2D, 0x4D],\n      encoding: 'windows-1254',\n      bytesPerCodePoint: 1 }]\n  },\n\n  // Japanese\n  'ISO 2022 IR 13': {\n    extension: true,\n    elements: [{ codeElement: 'G0',\n      escapeSequence: [0x1B, 0x28, 0x4A],\n      encoding: 'shift-jis',\n      bytesPerCodePoint: 1 },\n    { codeElement: 'G1',\n      escapeSequence: [0x1B, 0x29, 0x49],\n      encoding: 'shift-jis',\n      bytesPerCodePoint: 1 }]\n  },\n\n  // Thai\n  'ISO 2022 IR 166': {\n    extension: true,\n    elements: [asciiElement, { codeElement: 'G1',\n      escapeSequence: [0x1B, 0x2D, 0x54],\n      encoding: 'tis-620',\n      bytesPerCodePoint: 1 }]\n  },\n\n  /** ****************************\n   * Multi-byte with extensions *\n   ******************************/\n\n  // Japanese\n  'ISO 2022 IR 87': {\n    extension: true,\n    multiByte: true,\n    elements: [{ codeElement: 'G0',\n      escapeSequence: [0x1B, 0x24, 0x42],\n      encoding: 'euc-jp',\n      setHighBit: true,\n      bytesPerCodePoint: 2 }]\n  },\n\n  'ISO 2022 IR 159': {\n    extension: true,\n    multiByte: true,\n    elements: [{ codeElement: 'G0',\n      escapeSequence: [0x1B, 0x24, 0x28, 0x44],\n      encoding: 'euc-jp',\n      isJISX0212: true,\n      bytesPerCodePoint: 2 }]\n  },\n\n  // Korean\n  'ISO 2022 IR 149': {\n    extension: true,\n    multiByte: true,\n    elements: [{ codeElement: 'G1',\n      escapeSequence: [0x1B, 0x24, 0x29, 0x43],\n      encoding: 'euc-kr',\n      bytesPerCodePoint: 2 }]\n  },\n\n  // Simplified Chinese\n  'ISO 2022 IR 58': {\n    extension: true,\n    multiByte: true,\n    elements: [{ codeElement: 'G1',\n      escapeSequence: [0x1B, 0x24, 0x29, 0x41],\n      encoding: 'gb18030',\n      bytesPerCodePoint: 2 }]\n  },\n\n  /** *******************************\n   * Multi-byte without extensions *\n   *********************************/\n\n  'ISO_IR 192': { encoding: 'utf-8',\n    multiByte: true },\n\n  GB18030: { encoding: 'gb18030',\n    multiByte: true },\n\n  GBK: { encoding: 'gbk',\n    multiByte: true }\n};\n"],"sourceRoot":""}